#!/usr/bin/env bash
# claw-drive ‚Äî AI-managed personal drive
# https://github.com/dissaozw/claw-drive

set -euo pipefail

CLAW_DRIVE_VERSION="0.3.0"
# Resolve symlinks to find the real script location
CLAW_DRIVE_SCRIPT="${BASH_SOURCE[0]}"
while [[ -L "$CLAW_DRIVE_SCRIPT" ]]; do
  CLAW_DRIVE_LINK="$(readlink "$CLAW_DRIVE_SCRIPT")"
  if [[ "$CLAW_DRIVE_LINK" == /* ]]; then
    CLAW_DRIVE_SCRIPT="$CLAW_DRIVE_LINK"
  else
    CLAW_DRIVE_SCRIPT="$(dirname "$CLAW_DRIVE_SCRIPT")/$CLAW_DRIVE_LINK"
  fi
done
CLAW_DRIVE_ROOT="$(cd "$(dirname "$CLAW_DRIVE_SCRIPT")/.." && pwd)"

# Load libraries
source "$CLAW_DRIVE_ROOT/lib/config.sh"
source "$CLAW_DRIVE_ROOT/lib/index.sh"
source "$CLAW_DRIVE_ROOT/lib/dedup.sh"
source "$CLAW_DRIVE_ROOT/lib/sync.sh"
source "$CLAW_DRIVE_ROOT/lib/migrate.sh"
source "$CLAW_DRIVE_ROOT/lib/reindex.sh"

# --- Commands ---

cmd_init() {
  # Accept optional path argument
  if [[ -n "${1:-}" ]]; then
    CLAW_DRIVE_DIR="$1"
  fi

  # Resolve to absolute path
  if [[ "$CLAW_DRIVE_DIR" != /* ]]; then
    CLAW_DRIVE_DIR="$(cd "$(dirname "$CLAW_DRIVE_DIR")" 2>/dev/null && pwd)/$(basename "$CLAW_DRIVE_DIR")"
  fi

  # Update all derived paths
  CLAW_DRIVE_INDEX="$CLAW_DRIVE_DIR/INDEX.jsonl"
  CLAW_DRIVE_HASHES="$CLAW_DRIVE_DIR/.hashes"
  CLAW_DRIVE_SYNC_CONFIG="$CLAW_DRIVE_DIR/.sync-config"
  CLAW_DRIVE_SYNC_STATE="$CLAW_DRIVE_DIR/.sync-state"

  # Save path to config
  mkdir -p "$(dirname "$CLAW_DRIVE_CONFIG_FILE")"
  echo "$CLAW_DRIVE_DIR" > "$CLAW_DRIVE_CONFIG_FILE"

  echo "üóÑÔ∏è  Initializing Claw Drive at $CLAW_DRIVE_DIR"
  echo ""

  for cat in "${CLAW_DRIVE_CATEGORIES[@]}"; do
    mkdir -p "$CLAW_DRIVE_DIR/$cat"
    echo "  üìÇ $cat/"
  done

  if [[ ! -f "$CLAW_DRIVE_INDEX" ]]; then
    touch "$CLAW_DRIVE_INDEX"
    echo "  üìÑ INDEX.jsonl created"
  else
    echo "  üìÑ INDEX.jsonl exists"
  fi

  touch "$CLAW_DRIVE_HASHES"
  echo ""
  echo "‚úÖ Claw Drive ready at $CLAW_DRIVE_DIR"
}

# Validate a path component (category or filename) is safe ‚Äî no traversal or absolute paths
validate_path_component() {
  local label="$1" value="$2"
  if [[ -z "$value" ]]; then
    echo "‚ùå $label must not be empty"
    return 1
  fi
  if [[ "$value" == /* ]]; then
    echo "‚ùå $label must not be an absolute path: $value"
    return 1
  fi
  # Check for '..' as a path segment (not just substring, so file..name is OK)
  if [[ "$value" == ".." || "$value" == ../* || "$value" == */../* || "$value" == *"/.. " || "$value" == */.. ]]; then
    echo "‚ùå $label must not contain path traversal: $value"
    return 1
  fi
}

# Validate a filename has no path separators
validate_filename() {
  local label="$1" value="$2"
  validate_path_component "$label" "$value" || return 1
  if [[ "$value" == *"/"* ]]; then
    echo "‚ùå $label must not contain '/': $value"
    return 1
  fi
}

# Validate resolved path is inside the drive directory
validate_in_drive_dir() {
  local dest_path="$1"
  local resolved
  resolved=$(cd "$(dirname "$dest_path")" 2>/dev/null && echo "$(pwd)/$(basename "$dest_path")") || {
    echo "‚ùå Path resolution failed: $dest_path"
    return 1
  }
  local drive_resolved
  drive_resolved=$(cd "$CLAW_DRIVE_DIR" 2>/dev/null && pwd) || {
    echo "‚ùå Drive directory not accessible"
    return 1
  }
  if [[ "$resolved" != "$drive_resolved"/* ]]; then
    echo "‚ùå Path escapes drive directory: $dest_path"
    return 1
  fi
}

cmd_store() {
  local file="" category="" description="" tags="" source_name="" metadata=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --category|-c) category="$2"; shift 2 ;;
      --desc|-d) description="$2"; shift 2 ;;
      --tags|-t) tags="$2"; shift 2 ;;
      --source|-s) source_name="$2"; shift 2 ;;
      --name|-n) local custom_name="$2"; shift 2 ;;
      --metadata|-m) metadata="$2"; shift 2 ;;
      --json) local json_output=true; shift ;;
      *) file="$1"; shift ;;
    esac
  done

  if [[ -z "$file" || ! -f "$file" ]]; then
    echo "‚ùå Usage: claw-drive store <file> --category <cat> --desc <description> [--name <name>] [--tags <tags>] [--source <source>]"
    return 1
  fi

  claw_drive_init || return 1

  # Check for duplicates
  local existing
  if existing=$(dedup_check "$file"); then
    echo "‚ö†Ô∏è  Duplicate detected! File already exists at: $CLAW_DRIVE_DIR/$existing"
    return 1
  fi

  if [[ -z "$category" ]]; then
    echo "‚ùå --category is required"
    return 1
  fi

  if [[ -z "$description" ]]; then
    echo "‚ùå --desc is required"
    return 1
  fi

  # Validate path components against traversal
  validate_path_component "--category" "$category" || return 1
  [[ -n "${custom_name:-}" ]] && { validate_filename "--name" "$custom_name" || return 1; }

  # Build filename
  local basename
  basename="${custom_name:-$(basename "$file")}"
  local dest="$CLAW_DRIVE_DIR/$category/$basename"

  # Final defense: verify resolved path is inside drive dir
  mkdir -p "$CLAW_DRIVE_DIR/$category"
  validate_in_drive_dir "$dest" || return 1
  cp "$file" "$dest"

  # Register hash
  dedup_register "$dest" "$category/$basename"

  # Update index ‚Äî preserve original filename if renamed
  local date_str original_name_arg=""
  date_str=$(date +%Y-%m-%d)
  local original_file_name
  original_file_name=$(basename "$file")
  if [[ "$original_file_name" != "$basename" ]]; then
    original_name_arg="$original_file_name"
  fi
  index_add "$date_str" "$category/$basename" "$description" "${tags:-}" "${source_name:-manual}" "${metadata:-}" "$original_name_arg"

  if [[ "${json_output:-}" == "true" ]]; then
    printf '{"status":"stored","path":"%s","category":"%s","tags":"%s","hash":"%s"}\n' \
      "$category/$basename" "$category" "${tags:-}" "$(dedup_hash "$dest")"
  else
    echo "‚úÖ Stored: $category/$basename"
    [[ -n "$tags" ]] && echo "   Tags: $tags"
    echo "   Description: $description"
  fi
}

cmd_update() {
  local target_path="" desc="" tags="" metadata=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --desc|-d) desc="$2"; shift 2 ;;
      --tags|-t) tags="$2"; shift 2 ;;
      --metadata|-m) metadata="$2"; shift 2 ;;
      --json) shift ;;
      *) target_path="$1"; shift ;;
    esac
  done

  if [[ -z "$target_path" ]]; then
    echo "‚ùå Usage: claw-drive update <path> [--desc <description>] [--tags <tags>] [--metadata <json>]"
    return 1
  fi

  validate_path_component "path" "$target_path" || return 1

  if [[ -z "$desc" && -z "$tags" && -z "$metadata" ]]; then
    echo "‚ùå At least one of --desc, --tags, or --metadata is required"
    return 1
  fi

  claw_drive_init || return 1

  if ! index_has "$target_path"; then
    echo "‚ùå Not found in index: $target_path"
    return 1
  fi

  local update_args=()
  [[ -n "$desc" ]] && update_args+=(--desc "$desc")
  [[ -n "$tags" ]] && update_args+=(--tags "$tags")
  [[ -n "$metadata" ]] && update_args+=(--metadata "$metadata")

  index_update "$target_path" "${update_args[@]}"
  echo "‚úÖ Updated: $target_path"
  [[ -n "$desc" ]] && echo "   Description: $desc" || true
  [[ -n "$tags" ]] && echo "   Tags: $tags" || true
  [[ -n "$metadata" ]] && echo "   Metadata: $metadata" || true
}

cmd_delete() {
  local target_path="" force=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f) force=true; shift ;;
      *) target_path="$1"; shift ;;
    esac
  done

  if [[ -z "$target_path" ]]; then
    echo "‚ùå Usage: claw-drive delete <path> [--force]"
    return 1
  fi

  validate_path_component "path" "$target_path" || return 1

  claw_drive_init || return 1

  if ! index_has "$target_path"; then
    echo "‚ùå Not found in index: $target_path"
    return 1
  fi

  local full_path="$CLAW_DRIVE_DIR/$target_path"

  if [[ "$force" != "true" ]]; then
    echo "‚ö†Ô∏è  Will delete:"
    echo "   File: $full_path"
    echo "   Index entry: $target_path"
    echo ""
    echo "Run with --force to confirm."
    return 0
  fi

  # Remove file
  if [[ -f "$full_path" ]]; then
    rm "$full_path"
  elif [[ -d "$full_path" ]]; then
    rm -rf "$full_path"
  fi

  # Remove from index
  index_remove "$target_path"

  # Remove from dedup ledger
  dedup_unregister "$target_path"

  echo "‚úÖ Deleted: $target_path"
}

cmd_status() {
  local format="table"
  [[ "${1:-}" == "--json" ]] && format="json"

  echo "üóÑÔ∏è  Claw Drive Status"
  echo ""
  echo "üìÇ Directory: $CLAW_DRIVE_DIR"

  if [[ -d "$CLAW_DRIVE_DIR" ]]; then
    local file_count
    file_count=$(find "$CLAW_DRIVE_DIR" -type f \
      ! -name '.*' ! -name 'INDEX.jsonl' ! -name 'INDEX.md' ! -path '*/.git/*' | wc -l | xargs)
    echo "üìÑ Files: $file_count"

    local total_size
    total_size=$(du -sh "$CLAW_DRIVE_DIR" 2>/dev/null | awk '{print $1}')
    echo "üíæ Size: $total_size"
  else
    echo "‚ùå Directory not found"
  fi

  echo ""
  dedup_status "$format"
  echo ""
  sync_status "$format"
}

cmd_verify() {
  local fix=false
  [[ "${1:-}" == "--fix" ]] && fix=true

  claw_drive_init || return 1

  echo "üîç Verifying Claw Drive integrity..."
  echo ""

  local orphans=0 missing=0 hash_orphans=0 hash_missing=0 fixed=0

  # 1. Check indexed paths exist on disk
  while IFS= read -r line; do
    local path
    path=$(printf '%s' "$line" | jq -r '.path')
    local full="$CLAW_DRIVE_DIR/$path"
    if [[ ! -e "$full" ]]; then
      echo "  ‚ùå Missing on disk: $path"
      ((missing++)) || true
      if [[ "$fix" == "true" ]]; then
        index_remove "$path"
        dedup_unregister "$path"
        echo "     üîß Fixed: removed stale index entry"
        ((fixed++)) || true
      fi
    fi
  done < "$CLAW_DRIVE_INDEX"

  # 2. Check disk files are in index (orphans ‚Äî cannot auto-fix without metadata)
  local indexed_paths
  indexed_paths=$(jq -r '.path' "$CLAW_DRIVE_INDEX")

  while IFS= read -r -d '' filepath; do
    local basename
    basename=$(basename "$filepath")
    [[ "$basename" == .* || "$basename" == "INDEX.jsonl" || "$basename" == "INDEX.md" ]] && continue

    local rel="${filepath#$CLAW_DRIVE_DIR/}"

    # Check if this file is indexed directly or inside an indexed directory
    local found=false
    while IFS= read -r idx_path; do
      if [[ "$rel" == "$idx_path" ]]; then
        found=true
        break
      fi
      # Check if file is inside an indexed directory
      if [[ -d "$CLAW_DRIVE_DIR/$idx_path" && "$rel" == "$idx_path"* ]]; then
        found=true
        break
      fi
    done <<< "$indexed_paths"

    if [[ "$found" == "false" ]]; then
      echo "  ‚ö†Ô∏è  Orphan file (not indexed): $rel"
      ((orphans++)) || true
    fi
  done < <(find "$CLAW_DRIVE_DIR" -type f -not -path '*/.git/*' -not -name '.*' -not -name 'INDEX.jsonl' -not -name 'INDEX.md' -print0 | sort -z)

  # 3. Check hash consistency
  while IFS= read -r line; do
    local path
    path=$(printf '%s' "$line" | jq -r '.path')
    local full="$CLAW_DRIVE_DIR/$path"

    if [[ -f "$full" ]]; then
      local expected_hash
      # Use awk for exact path match (safe against regex special chars in paths)
      expected_hash=$(awk -v path="$path" '{
        hash = $1
        line_path = substr($0, index($0, "  ") + 2)
        if (line_path == path) { print hash; exit }
      }' "$CLAW_DRIVE_HASHES" 2>/dev/null || true)

      if [[ -z "$expected_hash" ]]; then
        echo "  ‚ö†Ô∏è  No hash registered: $path"
        ((hash_missing++)) || true
        if [[ "$fix" == "true" ]]; then
          dedup_register "$full" "$path"
          echo "     üîß Fixed: registered missing hash"
          ((fixed++)) || true
        fi
      else
        local actual_hash
        actual_hash=$(shasum -a 256 "$full" | awk '{print $1}')
        if [[ "$expected_hash" != "$actual_hash" ]]; then
          echo "  ‚ö†Ô∏è  Hash mismatch: $path"
          ((hash_orphans++)) || true
        fi
      fi
    fi
  done < "$CLAW_DRIVE_INDEX"

  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  local total=$((orphans + missing + hash_orphans + hash_missing))
  if [[ $total -eq 0 ]]; then
    echo "‚úÖ All clear ‚Äî index, disk, and hashes are aligned."
  else
    echo "Issues found:"
    [[ $missing -gt 0 ]] && echo "  ‚ùå Missing on disk: $missing"
    [[ $orphans -gt 0 ]] && echo "  ‚ö†Ô∏è  Orphan files: $orphans"
    [[ $hash_missing -gt 0 ]] && echo "  ‚ö†Ô∏è  Missing hashes: $hash_missing"
    [[ $hash_orphans -gt 0 ]] && echo "  ‚ö†Ô∏è  Hash mismatches: $hash_orphans"
    if [[ "$fix" == "true" ]]; then
      echo ""
      echo "üîß Auto-fixed: $fixed issue(s)"
      [[ $((orphans + hash_orphans)) -gt 0 ]] && \
        echo "   Manual review needed: $((orphans + hash_orphans)) issue(s) (orphans / hash mismatches)"
    else
      echo ""
      echo "üí° Tip: run 'claw-drive verify --fix' to auto-repair missing entries and hashes."
    fi
  fi
}

cmd_sync() {
  local subcmd="${1:-help}"
  shift || true

  case "$subcmd" in
    auth)    sync_auth ;;
    setup)   sync_setup ;;
    push)    sync_push ;;
    start)   sync_start ;;
    stop)    sync_stop ;;
    status)  sync_status "${1:-table}" ;;
    _watch)  sync_watch_loop ;;
    help|*)
      echo "Usage: claw-drive sync <command>"
      echo ""
      echo "Commands:"
      echo "  auth    ‚Äî authorize Google Drive (one-time, opens browser)"
      echo "  setup   ‚Äî check dependencies and configuration"
      echo "  push    ‚Äî one-shot sync to remote"
      echo "  start   ‚Äî start background sync daemon"
      echo "  stop    ‚Äî stop background sync daemon"
      echo "  status  ‚Äî show sync status"
      ;;
  esac
}

cmd_migrate() {
  local subcmd="${1:-help}"
  shift || true

  case "$subcmd" in
    scan)
      local source_dir="${1:-}"
      local output="${2:-migration-plan.json}"
      if [[ -z "$source_dir" ]]; then
        echo "‚ùå Usage: claw-drive migrate scan <source-dir> [output.json]"
        return 1
      fi
      migrate_scan "$source_dir" "$output"
      ;;
    apply)
      local plan="${1:-migration-plan.json}"
      local dry_run="false"
      [[ "${2:-}" == "--dry-run" ]] && dry_run="true"
      migrate_apply "$plan" "$dry_run"
      ;;
    summary)
      local plan="${1:-migration-plan.json}"
      migrate_summary "$plan"
      ;;
    help|*)
      echo "Usage: claw-drive migrate <command>"
      echo ""
      echo "Commands:"
      echo "  scan <source-dir> [output.json]   ‚Äî scan directory, output plan"
      echo "  summary [plan.json]               ‚Äî show plan summary"
      echo "  apply [plan.json] [--dry-run]     ‚Äî execute migration plan"
      echo ""
      echo "Workflow:"
      echo "  1. claw-drive migrate scan ~/messy-folder"
      echo "  2. AI agent classifies files in migration-plan.json"
      echo "  3. claw-drive migrate summary    (review)"
      echo "  4. claw-drive migrate apply      (execute)"
      ;;
  esac
}

cmd_reindex() {
  local subcmd="${1:-help}"
  shift || true

  case "$subcmd" in
    scan)    reindex_scan "$@" ;;
    apply)   reindex_apply "$@" ;;
    help|*)
      echo "Usage: claw-drive reindex <command>"
      echo ""
      echo "Commands:"
      echo "  scan [--output plan.json]     ‚Äî scan drive, output reindex plan"
      echo "  apply <plan.json> [--dry-run] ‚Äî apply enriched plan to index"
      echo ""
      echo "Workflow:"
      echo "  1. claw-drive reindex scan"
      echo "  2. Agent enriches reindex-plan.json (adds desc/tags for orphans, new_desc/new_tags for existing)"
      echo "  3. claw-drive reindex apply reindex-plan.json --dry-run  (preview)"
      echo "  4. claw-drive reindex apply reindex-plan.json            (commit)"
      ;;
  esac
}

cmd_version() {
  echo "claw-drive $CLAW_DRIVE_VERSION"
}

cmd_help() {
  cat <<EOF
üóÑÔ∏è  Claw Drive ‚Äî AI-managed personal drive

Usage: claw-drive <command> [options]

Commands:
  init [path]                   Initialize drive at path (default: ~/claw-drive)
  store <file> [options]        Store a file with categorization
  update <path> [options]       Update description/tags on an entry
  delete <path> [--force]       Delete a file and its index entry
  status [--json]               Show drive status
  verify [--fix]                Check index ‚Üî disk ‚Üî hash consistency; --fix auto-repairs
  migrate <subcommand>          Migrate files from existing directory
  reindex <subcommand>          Scan and re-enrich index entries
  sync auth                     Authorize Google Drive (one-time)
  sync <subcommand>             Manage Google Drive sync
  version                       Show version
  help                          Show this help

Store options:
  --category, -c <category>     Target category (required)
  --desc, -d <description>      File description (required)
  --name, -n <filename>         Custom filename (default: original name)
  --tags, -t <tag1,tag2>        Comma-separated tags
  --source, -s <source>         Source (email, telegram, manual)
  --metadata, -m <json>         Custom metadata JSON (e.g. '{"expiry":"2027-01","amount":"\$150"}')
  --json                        JSON output

Environment:
  CLAW_DRIVE_DIR                Drive directory (default: ~/claw-drive)

https://github.com/dissaozw/claw-drive
EOF
}

# --- Main ---

case "${1:-help}" in
  init)     shift; cmd_init "$@" ;;
  store)    shift; cmd_store "$@" ;;
  update)   shift; cmd_update "$@" ;;
  delete|rm) shift; cmd_delete "$@" ;;
  status)   shift; cmd_status "$@" ;;
  verify)   shift; cmd_verify "$@" ;;
  migrate)  shift; cmd_migrate "$@" ;;
  reindex)  shift; cmd_reindex "$@" ;;
  sync)     shift; cmd_sync "$@" ;;
  version|--version|-v) cmd_version ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "Unknown command: $1"
    echo "Run 'claw-drive help' for usage."
    exit 1
    ;;
esac
